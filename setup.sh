#!/bin/bash
set -e

# =============================================================================
# Castle.lan Shell Environment Setup
# =============================================================================
#
# Usage:
#   ./setup.sh              Interactive PC mode
#   ./setup.sh --yes        Unattended PC mode (defaults to zsh)
#   ./setup.sh --server     Unattended server mode (core tools only, nano editor)
#   ./setup.sh --bash       Use bash instead of zsh
#
# Modes:
#   pc     - Full setup: dev tools, starship, EDITOR=code
#   server - Minimal: core CLI tools only, EDITOR=nano
#
# =============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source common helpers
source "$SCRIPT_DIR/lib/common.sh"

# State
INSTALLED=()
SELECTED_SHELL=""
INSTALL_ALL=false
MODE="pc"

# Managed block markers
MARKER_START="# >>> castle.lan >>>"
MARKER_END="# <<< castle.lan <<<"

# =============================================================================
# MODULE LOADING
# =============================================================================

MODULES=()

load_modules() {
    for module_file in "$SCRIPT_DIR/modules/"*.sh; do
        [ -f "$module_file" ] || continue
        source "$module_file"
        MODULES+=("$module_file")
    done
}

run_installs() {
    for module_file in "${MODULES[@]}"; do
        source "$module_file"  # Re-source to get MODULE_MODE
        
        # Skip dev modules in server mode
        if [ "$MODE" = "server" ] && [ "$MODULE_MODE" = "dev" ]; then
            continue
        fi
        
        module_install
    done
}

# =============================================================================
# CONFIG GENERATION
# =============================================================================

generate_aliases() {
    echo "# Aliases - Generated by castle.lan"
    echo ""
    
    for module_file in "${MODULES[@]}"; do
        source "$module_file"
        module_aliases
    done
    
    # Shell quick edits
    local ext="$SELECTED_SHELL"
    local rc=".$SELECTED_SHELL"rc
    [ "$SELECTED_SHELL" = "bash" ] && rc=".bashrc"
    
    cat <<EOF

# Shell quick edits
alias shrc='\$EDITOR ~/$rc'
alias shaliases='\$EDITOR ~/.config/$ext/aliases.$ext'
alias shfuncs='\$EDITOR ~/.config/$ext/functions.$ext'
alias shenv='\$EDITOR ~/.config/$ext/env.$ext'
alias reload='source ~/$rc'
EOF
}

generate_functions() {
    echo "# Functions - Generated by castle.lan"
    echo ""
    
    for module_file in "${MODULES[@]}"; do
        source "$module_file"
        module_functions
    done
}

generate_env() {
    echo "# Environment - Generated by castle.lan"
    echo ""
    
    # Mode-specific settings
    if [ "$MODE" = "server" ]; then
        echo "export EDITOR=nano"
    else
        echo "export EDITOR=code"
        echo "export BROWSER=chrome"
    fi
    echo ""
    
    for module_file in "${MODULES[@]}"; do
        source "$module_file"
        module_env
    done
}

generate_paths() {
    for module_file in "${MODULES[@]}"; do
        source "$module_file"
        module_paths
    done
}

# =============================================================================
# SHELL CONFIGURATION
# =============================================================================

remove_managed_block() {
    local file="$1"
    [ -f "$file" ] || return 0
    if grep -q "$MARKER_START" "$file"; then
        sed -i "/$MARKER_START/,/$MARKER_END/d" "$file"
    fi
}

append_managed_block() {
    local file="$1"
    local content="$2"
    {
        echo ""
        echo "$MARKER_START"
        echo "$content"
        echo "$MARKER_END"
    } >> "$file"
}

configure_shell() {
    local rc config_dir ext
    
    if [ "$SELECTED_SHELL" = "zsh" ]; then
        rc="$HOME/.zshrc"
        config_dir="$HOME/.config/zsh"
        ext="zsh"
    else
        rc="$HOME/.bashrc"
        config_dir="$HOME/.config/bash"
        ext="bash"
    fi
    
    mkdir -p "$config_dir"
    
    # Backup original
    [ ! -f "$rc.pre-castle" ] && [ -f "$rc" ] && cp "$rc" "$rc.pre-castle"
    
    # Generate config files
    generate_aliases > "$config_dir/aliases.$ext"
    generate_functions > "$config_dir/functions.$ext"
    generate_env > "$config_dir/env.$ext"
    info "Generated $config_dir/{aliases,functions,env}.$ext"
    
    # Create rc file if missing (zsh only)
    if [ "$SELECTED_SHELL" = "zsh" ] && [ ! -f "$rc" ]; then
        cat <<'EOF' > "$rc"
# Zsh Configuration

# History
HISTFILE=~/.zsh_history
HISTSIZE=10000
SAVEHIST=10000
setopt APPEND_HISTORY SHARE_HISTORY INC_APPEND_HISTORY
setopt HIST_IGNORE_DUPS HIST_IGNORE_ALL_DUPS

# Completion
autoload -Uz compinit && compinit
EOF
        info "Created new ~/.zshrc"
    fi
    
    # Remove old managed block
    remove_managed_block "$rc"
    
    # Build managed block
    local block
    block=$(cat <<EOF
# Source castle.lan config
[ -f ~/.config/$ext/env.$ext ] && source ~/.config/$ext/env.$ext
[ -f ~/.config/$ext/aliases.$ext ] && source ~/.config/$ext/aliases.$ext
[ -f ~/.config/$ext/functions.$ext ] && source ~/.config/$ext/functions.$ext

EOF
)
    block+="$(generate_paths)"
    
    append_managed_block "$rc" "$block"
    info "Configured ~/.$ext""rc"
}

# =============================================================================
# PREREQUISITES
# =============================================================================

install_prerequisites() {
    info "Ensuring prerequisites..."
    local pkgs=()
    has curl || pkgs+=(curl)
    has nano || pkgs+=(nano)
    
    if [ ${#pkgs[@]} -gt 0 ]; then
        sudo apt update && sudo apt install -y "${pkgs[@]}"
        INSTALLED+=("${pkgs[@]}")
    fi
}

install_zsh() {
    has zsh && { info "zsh already installed"; return 0; }
    info "Installing zsh..."
    sudo apt update && sudo apt install -y zsh
    INSTALLED+=("zsh")
}

set_default_shell() {
    local target
    target=$(which "$SELECTED_SHELL")
    if [ "$SHELL" != "$target" ]; then
        info "Setting $SELECTED_SHELL as default shell..."
        chsh -s "$target"
        INSTALLED+=("default-shell:$SELECTED_SHELL")
    else
        info "$SELECTED_SHELL is already default"
    fi
}

prompt_shell() {
    echo -e "${BLUE}${BOLD}?${NC} Which shell to configure?"
    echo "  1) zsh"
    echo "  2) bash"
    while true; do
        echo -en "Choice [1/2]: "
        read -r choice
        case "$choice" in
            1|zsh)  SELECTED_SHELL="zsh"; return ;;
            2|bash) SELECTED_SHELL="bash"; return ;;
            *) echo "Enter 1 or 2." ;;
        esac
    done
}

# =============================================================================
# MAIN
# =============================================================================

main() {
    # Parse flags
    for arg in "$@"; do
        case "$arg" in
            --yes|-y)   INSTALL_ALL=true ;;
            --zsh)      SELECTED_SHELL="zsh" ;;
            --bash)     SELECTED_SHELL="bash" ;;
            --server)   MODE="server"; INSTALL_ALL=true ;;
            --pc)       MODE="pc" ;;
            --help|-h)  
                head -16 "$0" | tail -13
                exit 0
                ;;
        esac
    done

    # Default to zsh for unattended install
    $INSTALL_ALL && [ -z "$SELECTED_SHELL" ] && SELECTED_SHELL="zsh"
    
    # Interactive shell selection
    [ -z "$SELECTED_SHELL" ] && prompt_shell
    
    info "Mode: $MODE"
    info "Target shell: $SELECTED_SHELL"

    # Load all modules
    load_modules

    # Prerequisites (always in server mode)
    [ "$MODE" = "server" ] && install_prerequisites

    # Install zsh if selected
    [[ "$SELECTED_SHELL" == "zsh" ]] && prompt "Install zsh?" && install_zsh

    # Run module installs
    run_installs

    # Configure shell
    prompt "Configure $SELECTED_SHELL?" && configure_shell

    # Set default shell
    prompt "Set $SELECTED_SHELL as default?" && set_default_shell

    # Summary
    echo ""
    echo -e "${GREEN}${BOLD}Done!${NC} (mode: $MODE)"
    if [ ${#INSTALLED[@]} -gt 0 ]; then
        echo "Installed/configured: ${INSTALLED[*]}"
    fi
    echo "Restart your shell or run: source ~/.$SELECTED_SHELL""rc"
}

main "$@"
